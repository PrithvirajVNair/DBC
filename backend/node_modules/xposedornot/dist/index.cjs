'use strict';

// src/types/config.ts
var DEFAULT_CONFIG = {
  baseUrl: "https://api.xposedornot.com",
  timeout: 3e4,
  retries: 3,
  headers: {}
};

// src/errors/index.ts
var XposedOrNotError = class extends Error {
  constructor(message, code, statusCode) {
    super(message);
    this.code = code;
    this.statusCode = statusCode;
    this.name = "XposedOrNotError";
    if (typeof Error.captureStackTrace === "function") {
      Error.captureStackTrace(this, this.constructor);
    }
  }
};
var RateLimitError = class extends XposedOrNotError {
  constructor(message = "Rate limit exceeded. Please slow down your requests.", retryAfter) {
    super(message, "RATE_LIMIT_EXCEEDED", 429);
    this.retryAfter = retryAfter;
    this.name = "RateLimitError";
  }
};
var NotFoundError = class extends XposedOrNotError {
  constructor(message = "Resource not found") {
    super(message, "NOT_FOUND", 404);
    this.name = "NotFoundError";
  }
};
var AuthenticationError = class extends XposedOrNotError {
  constructor(message = "Authentication failed. Check your API key.") {
    super(message, "AUTHENTICATION_FAILED", 401);
    this.name = "AuthenticationError";
  }
};
var ValidationError = class extends XposedOrNotError {
  constructor(message, field) {
    super(message, "VALIDATION_ERROR");
    this.field = field;
    this.name = "ValidationError";
  }
};
var NetworkError = class extends XposedOrNotError {
  constructor(message = "A network error occurred", cause) {
    super(message, "NETWORK_ERROR");
    this.cause = cause;
    this.name = "NetworkError";
  }
};
var TimeoutError = class extends XposedOrNotError {
  constructor(message = "Request timed out") {
    super(message, "TIMEOUT");
    this.name = "TimeoutError";
  }
};
var ApiError = class extends XposedOrNotError {
  constructor(message, statusCode, response) {
    super(message, "API_ERROR", statusCode);
    this.response = response;
    this.name = "ApiError";
  }
};

// src/utils/http.ts
var HttpClient = class {
  constructor(config) {
    this.config = config;
  }
  /**
   * Make an HTTP request to the API
   */
  async request(endpoint, options = {}) {
    const { method = "GET", headers = {}, body, params } = options;
    const url = this.buildUrl(endpoint, params);
    const controller = new AbortController();
    const timeoutId = setTimeout(() => {
      controller.abort();
    }, this.config.timeout);
    const requestHeaders = {
      "Content-Type": "application/json",
      Accept: "application/json",
      ...this.config.headers,
      ...headers
    };
    let lastError;
    let attempt = 0;
    while (attempt < this.config.retries) {
      attempt++;
      try {
        const response = await fetch(url, {
          method,
          headers: requestHeaders,
          body: body ? JSON.stringify(body) : void 0,
          signal: controller.signal
        });
        clearTimeout(timeoutId);
        return await this.handleResponse(response);
      } catch (error) {
        lastError = error;
        if (error instanceof XposedOrNotError) {
          if (error.statusCode && error.statusCode >= 400 && error.statusCode < 500) {
            if (!(error instanceof RateLimitError)) {
              throw error;
            }
          }
        }
        if (error instanceof Error && error.name === "AbortError") {
          throw new TimeoutError(`Request timed out after ${this.config.timeout}ms`);
        }
        if (attempt < this.config.retries) {
          const delay = Math.min(1e3 * Math.pow(2, attempt - 1), 1e4);
          await this.sleep(delay);
        }
      }
    }
    if (lastError instanceof XposedOrNotError) {
      throw lastError;
    }
    throw new NetworkError(
      `Request failed after ${this.config.retries} attempts: ${lastError?.message}`,
      lastError
    );
  }
  /**
   * Build the full URL with query parameters
   */
  buildUrl(endpoint, params) {
    const url = new URL(endpoint, this.config.baseUrl);
    if (params) {
      for (const [key, value] of Object.entries(params)) {
        if (value !== void 0) {
          url.searchParams.set(key, String(value));
        }
      }
    }
    return url.toString();
  }
  /**
   * Handle the API response
   */
  async handleResponse(response) {
    if (response.status === 304) {
      return {};
    }
    let data;
    const contentType = response.headers.get("content-type");
    if (contentType?.includes("application/json")) {
      try {
        data = await response.json();
      } catch {
        data = null;
      }
    } else {
      data = await response.text();
    }
    if (response.ok) {
      return data;
    }
    this.handleErrorResponse(response.status, data);
  }
  /**
   * Handle error responses from the API
   */
  handleErrorResponse(status, data) {
    const message = this.extractErrorMessage(data);
    switch (status) {
      case 401:
        throw new AuthenticationError(message);
      case 404:
        throw new NotFoundError(message);
      case 429: {
        const retryAfter = this.extractRetryAfter(data);
        throw new RateLimitError(message, retryAfter);
      }
      default:
        throw new ApiError(message || `API error: ${status}`, status, data);
    }
  }
  /**
   * Extract error message from response data
   */
  extractErrorMessage(data) {
    if (typeof data === "string") {
      return data;
    }
    if (data && typeof data === "object") {
      const obj = data;
      if (typeof obj.Error === "string") return obj.Error;
      if (typeof obj.error === "string") return obj.error;
      if (typeof obj.message === "string") return obj.message;
    }
    return "An unknown error occurred";
  }
  /**
   * Extract retry-after value from response
   */
  extractRetryAfter(data) {
    if (data && typeof data === "object") {
      const obj = data;
      if (typeof obj.retry_after === "number") return obj.retry_after;
      if (typeof obj.retryAfter === "number") return obj.retryAfter;
    }
    return void 0;
  }
  /**
   * Sleep for a given duration
   */
  sleep(ms) {
    return new Promise((resolve) => setTimeout(resolve, ms));
  }
};

// src/endpoints/breaches.ts
async function getBreaches(http, options = {}) {
  const params = {};
  if (options.domain) {
    params.domain = options.domain;
  }
  if (options.breachId) {
    params.breach_id = options.breachId;
  }
  const response = await http.request("/v1/breaches", {
    params
  });
  return response.exposedBreaches ?? [];
}

// src/utils/validation.ts
var EMAIL_REGEX = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
function validateEmail(email) {
  if (typeof email !== "string") {
    throw new ValidationError("Email must be a string", "email");
  }
  const trimmed = email.trim();
  if (!trimmed) {
    throw new ValidationError("Email is required", "email");
  }
  if (!EMAIL_REGEX.test(trimmed)) {
    throw new ValidationError("Invalid email format", "email");
  }
  if (trimmed.length > 254) {
    throw new ValidationError("Email is too long (max 254 characters)", "email");
  }
}
function normalizeEmail(email) {
  return email.trim().toLowerCase();
}
function sanitizeEmailForPath(email) {
  return encodeURIComponent(normalizeEmail(email));
}

// src/endpoints/check-email.ts
function isFoundResponse(response) {
  return "breaches" in response && Array.isArray(response.breaches);
}
async function checkEmail(http, email, options = {}) {
  validateEmail(email);
  const sanitizedEmail = sanitizeEmailForPath(email);
  const params = {};
  if (options.includeDetails) {
    params.include_details = options.includeDetails;
  }
  try {
    const response = await http.request(`/v1/check-email/${sanitizedEmail}`, {
      params
    });
    if (isFoundResponse(response)) {
      const breaches = response.breaches.flat();
      return {
        email: response.email,
        found: true,
        breaches
      };
    }
    return {
      email: response.email,
      found: false,
      breaches: []
    };
  } catch (error) {
    if (error instanceof NotFoundError) {
      return {
        email,
        found: false,
        breaches: []
      };
    }
    throw error;
  }
}

// src/endpoints/breach-analytics.ts
async function getBreachAnalytics(http, email, options = {}) {
  validateEmail(email);
  const normalizedEmail = normalizeEmail(email);
  const params = {
    email: normalizedEmail
  };
  if (options.token) {
    params.token = options.token;
  }
  try {
    const response = await http.request("/v1/breach-analytics", {
      params
    });
    const breachDetails = response.ExposedBreaches?.breaches_details;
    const hasBreaches = breachDetails !== void 0 && breachDetails.length > 0;
    const hasPastes = Array.isArray(response.ExposedPastes) && response.ExposedPastes.length > 0;
    return {
      email,
      found: hasBreaches || hasPastes,
      analytics: response
    };
  } catch (error) {
    if (error instanceof NotFoundError) {
      return {
        email,
        found: false,
        analytics: null
      };
    }
    throw error;
  }
}

// src/client.ts
var XposedOrNot = class {
  config;
  http;
  /**
   * Create a new XposedOrNot client
   *
   * @param config - Optional configuration options
   */
  constructor(config = {}) {
    this.config = this.resolveConfig(config);
    this.http = new HttpClient(this.config);
  }
  /**
   * Merge user config with defaults and validate
   */
  resolveConfig(config) {
    const baseUrl = config.baseUrl ?? DEFAULT_CONFIG.baseUrl;
    this.validateBaseUrl(baseUrl);
    const timeout = config.timeout ?? DEFAULT_CONFIG.timeout;
    this.validateTimeout(timeout);
    const retries = config.retries ?? DEFAULT_CONFIG.retries;
    this.validateRetries(retries);
    return {
      baseUrl,
      timeout,
      retries,
      headers: {
        ...DEFAULT_CONFIG.headers,
        ...config.headers
      }
    };
  }
  /**
   * Validate baseUrl - must be HTTPS
   */
  validateBaseUrl(baseUrl) {
    let url;
    try {
      url = new URL(baseUrl);
    } catch {
      throw new ValidationError(`Invalid baseUrl: "${baseUrl}" is not a valid URL`, "baseUrl");
    }
    if (url.protocol !== "https:") {
      throw new ValidationError(
        `Invalid baseUrl: must use HTTPS protocol (got "${url.protocol}")`,
        "baseUrl"
      );
    }
  }
  /**
   * Validate timeout - must be between 1000ms and 5 minutes
   */
  validateTimeout(timeout) {
    const MIN_TIMEOUT = 1e3;
    const MAX_TIMEOUT = 3e5;
    if (typeof timeout !== "number" || !Number.isFinite(timeout)) {
      throw new ValidationError("Invalid timeout: must be a finite number", "timeout");
    }
    if (timeout < MIN_TIMEOUT || timeout > MAX_TIMEOUT) {
      throw new ValidationError(
        `Invalid timeout: must be between ${MIN_TIMEOUT}ms and ${MAX_TIMEOUT}ms (got ${timeout}ms)`,
        "timeout"
      );
    }
  }
  /**
   * Validate retries - must be between 0 and 10
   */
  validateRetries(retries) {
    const MIN_RETRIES = 0;
    const MAX_RETRIES = 10;
    if (typeof retries !== "number" || !Number.isInteger(retries)) {
      throw new ValidationError("Invalid retries: must be an integer", "retries");
    }
    if (retries < MIN_RETRIES || retries > MAX_RETRIES) {
      throw new ValidationError(
        `Invalid retries: must be between ${MIN_RETRIES} and ${MAX_RETRIES} (got ${retries})`,
        "retries"
      );
    }
  }
  /**
   * Check if an email address has been exposed in any data breaches
   *
   * @param email - Email address to check
   * @param options - Optional parameters
   * @returns Result indicating if email was found and which breaches
   *
   * @example
   * ```typescript
   * const result = await xon.checkEmail('user@example.com');
   *
   * if (result.found) {
   *   console.log(`Found in ${result.breaches.length} breaches:`);
   *   result.breaches.forEach(breach => console.log(`  - ${breach}`));
   * } else {
   *   console.log('Good news! Email not found in any known breaches.');
   * }
   * ```
   */
  async checkEmail(email, options) {
    return checkEmail(this.http, email, options);
  }
  /**
   * Get a list of all known data breaches
   *
   * @param options - Optional filters for domain or specific breach
   * @returns Array of breach information
   *
   * @example
   * ```typescript
   * // Get all breaches
   * const allBreaches = await xon.getBreaches();
   * console.log(`Total breaches: ${allBreaches.length}`);
   *
   * // Filter by domain
   * const adobeBreaches = await xon.getBreaches({ domain: 'adobe.com' });
   *
   * // Get specific breach by ID
   * const linkedIn = await xon.getBreaches({ breachId: 'linkedin' });
   * ```
   */
  async getBreaches(options) {
    return getBreaches(this.http, options);
  }
  /**
   * Get detailed breach analytics for an email address
   *
   * Provides comprehensive information including:
   * - List of breaches where the email was found
   * - Breach summary and metrics
   * - Paste exposures (if any)
   *
   * @param email - Email address to get analytics for
   * @param options - Optional parameters including access token
   * @returns Detailed analytics about breaches and exposures
   *
   * @example
   * ```typescript
   * const result = await xon.getBreachAnalytics('user@example.com');
   *
   * if (result.found && result.analytics) {
   *   const { ExposedBreaches, BreachesSummary, BreachMetrics } = result.analytics;
   *
   *   console.log('Exposed in breaches:', ExposedBreaches);
   *   console.log('Summary:', BreachesSummary);
   *   console.log('Metrics:', BreachMetrics);
   * }
   * ```
   */
  async getBreachAnalytics(email, options) {
    return getBreachAnalytics(this.http, email, options);
  }
};

exports.ApiError = ApiError;
exports.AuthenticationError = AuthenticationError;
exports.NetworkError = NetworkError;
exports.NotFoundError = NotFoundError;
exports.RateLimitError = RateLimitError;
exports.TimeoutError = TimeoutError;
exports.ValidationError = ValidationError;
exports.XposedOrNot = XposedOrNot;
exports.XposedOrNotError = XposedOrNotError;
//# sourceMappingURL=index.cjs.map
//# sourceMappingURL=index.cjs.map