{"version":3,"sources":["../src/types/config.ts","../src/errors/index.ts","../src/utils/http.ts","../src/endpoints/breaches.ts","../src/utils/validation.ts","../src/endpoints/check-email.ts","../src/endpoints/breach-analytics.ts","../src/client.ts"],"names":[],"mappings":"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","file":"index.js","sourcesContent":["/**\n * Configuration options for the XposedOrNot client\n */\nexport interface XposedOrNotConfig {\n  /**\n   * Base URL for the API (must use HTTPS)\n   * @default 'https://api.xposedornot.com'\n   * @throws {ValidationError} If not a valid HTTPS URL\n   */\n  baseUrl?: string;\n\n  /**\n   * Request timeout in milliseconds (1000-300000)\n   * @default 30000\n   * @throws {ValidationError} If outside valid range\n   */\n  timeout?: number;\n\n  /**\n   * Number of retry attempts for failed requests (0-10)\n   * @default 3\n   * @throws {ValidationError} If outside valid range\n   */\n  retries?: number;\n\n  /**\n   * Custom headers to include in all requests\n   */\n  headers?: Record<string, string>;\n}\n\n/**\n * Internal resolved configuration with all defaults applied\n */\nexport interface ResolvedConfig {\n  baseUrl: string;\n  timeout: number;\n  retries: number;\n  headers: Record<string, string>;\n}\n\nexport const DEFAULT_CONFIG: ResolvedConfig = {\n  baseUrl: 'https://api.xposedornot.com',\n  timeout: 30000,\n  retries: 3,\n  headers: {},\n};\n","/**\n * Base error class for all XposedOrNot errors\n */\nexport class XposedOrNotError extends Error {\n  constructor(\n    message: string,\n    public readonly code: string,\n    public readonly statusCode?: number\n  ) {\n    super(message);\n    this.name = 'XposedOrNotError';\n    // V8-specific stack trace capture (Node.js, Chrome)\n    if (typeof Error.captureStackTrace === 'function') {\n      Error.captureStackTrace(this, this.constructor);\n    }\n  }\n}\n\n/**\n * Error thrown when the API rate limit is exceeded\n */\nexport class RateLimitError extends XposedOrNotError {\n  constructor(\n    message = 'Rate limit exceeded. Please slow down your requests.',\n    public readonly retryAfter?: number\n  ) {\n    super(message, 'RATE_LIMIT_EXCEEDED', 429);\n    this.name = 'RateLimitError';\n  }\n}\n\n/**\n * Error thrown when a resource is not found (e.g., email not in any breaches)\n */\nexport class NotFoundError extends XposedOrNotError {\n  constructor(message = 'Resource not found') {\n    super(message, 'NOT_FOUND', 404);\n    this.name = 'NotFoundError';\n  }\n}\n\n/**\n * Error thrown when authentication fails\n */\nexport class AuthenticationError extends XposedOrNotError {\n  constructor(message = 'Authentication failed. Check your API key.') {\n    super(message, 'AUTHENTICATION_FAILED', 401);\n    this.name = 'AuthenticationError';\n  }\n}\n\n/**\n * Error thrown when input validation fails\n */\nexport class ValidationError extends XposedOrNotError {\n  constructor(\n    message: string,\n    public readonly field?: string\n  ) {\n    super(message, 'VALIDATION_ERROR');\n    this.name = 'ValidationError';\n  }\n}\n\n/**\n * Error thrown when a network error occurs\n */\nexport class NetworkError extends XposedOrNotError {\n  constructor(\n    message = 'A network error occurred',\n    public readonly cause?: Error\n  ) {\n    super(message, 'NETWORK_ERROR');\n    this.name = 'NetworkError';\n  }\n}\n\n/**\n * Error thrown when the request times out\n */\nexport class TimeoutError extends XposedOrNotError {\n  constructor(message = 'Request timed out') {\n    super(message, 'TIMEOUT');\n    this.name = 'TimeoutError';\n  }\n}\n\n/**\n * Error thrown when the API returns an unexpected response\n */\nexport class ApiError extends XposedOrNotError {\n  constructor(\n    message: string,\n    statusCode: number,\n    public readonly response?: unknown\n  ) {\n    super(message, 'API_ERROR', statusCode);\n    this.name = 'ApiError';\n  }\n}\n","import type { ResolvedConfig } from '../types/config.js';\nimport {\n  XposedOrNotError,\n  RateLimitError,\n  NotFoundError,\n  AuthenticationError,\n  NetworkError,\n  TimeoutError,\n  ApiError,\n} from '../errors/index.js';\n\nexport interface RequestOptions {\n  method?: 'GET' | 'POST' | 'PUT' | 'DELETE';\n  headers?: Record<string, string>;\n  body?: unknown;\n  params?: Record<string, string | boolean | undefined>;\n}\n\n/**\n * HTTP client for making API requests\n */\nexport class HttpClient {\n  constructor(private readonly config: ResolvedConfig) {}\n\n  /**\n   * Make an HTTP request to the API\n   */\n  async request<T>(endpoint: string, options: RequestOptions = {}): Promise<T> {\n    const { method = 'GET', headers = {}, body, params } = options;\n\n    const url = this.buildUrl(endpoint, params);\n    const controller = new AbortController();\n    const timeoutId = setTimeout(() => {\n      controller.abort();\n    }, this.config.timeout);\n\n    const requestHeaders: Record<string, string> = {\n      'Content-Type': 'application/json',\n      Accept: 'application/json',\n      ...this.config.headers,\n      ...headers,\n    };\n\n    let lastError: Error | undefined;\n    let attempt = 0;\n\n    while (attempt < this.config.retries) {\n      attempt++;\n\n      try {\n        const response = await fetch(url, {\n          method,\n          headers: requestHeaders,\n          body: body ? JSON.stringify(body) : undefined,\n          signal: controller.signal,\n        });\n\n        clearTimeout(timeoutId);\n\n        return await this.handleResponse<T>(response);\n      } catch (error) {\n        lastError = error as Error;\n\n        if (error instanceof XposedOrNotError) {\n          // Don't retry on client errors (4xx) except rate limits\n          if (error.statusCode && error.statusCode >= 400 && error.statusCode < 500) {\n            if (!(error instanceof RateLimitError)) {\n              throw error;\n            }\n          }\n        }\n\n        if (error instanceof Error && error.name === 'AbortError') {\n          throw new TimeoutError(`Request timed out after ${this.config.timeout}ms`);\n        }\n\n        // Wait before retrying (exponential backoff)\n        if (attempt < this.config.retries) {\n          const delay = Math.min(1000 * Math.pow(2, attempt - 1), 10000);\n          await this.sleep(delay);\n        }\n      }\n    }\n\n    // All retries exhausted\n    if (lastError instanceof XposedOrNotError) {\n      throw lastError;\n    }\n\n    throw new NetworkError(\n      `Request failed after ${this.config.retries} attempts: ${lastError?.message}`,\n      lastError\n    );\n  }\n\n  /**\n   * Build the full URL with query parameters\n   */\n  private buildUrl(\n    endpoint: string,\n    params?: Record<string, string | boolean | undefined>\n  ): string {\n    const url = new URL(endpoint, this.config.baseUrl);\n\n    if (params) {\n      for (const [key, value] of Object.entries(params)) {\n        if (value !== undefined) {\n          url.searchParams.set(key, String(value));\n        }\n      }\n    }\n\n    return url.toString();\n  }\n\n  /**\n   * Handle the API response\n   */\n  private async handleResponse<T>(response: Response): Promise<T> {\n    if (response.status === 304) {\n      // Not modified - return empty response\n      return {} as T;\n    }\n\n    let data: unknown;\n    const contentType = response.headers.get('content-type');\n\n    if (contentType?.includes('application/json')) {\n      try {\n        data = await response.json();\n      } catch {\n        data = null;\n      }\n    } else {\n      data = await response.text();\n    }\n\n    if (response.ok) {\n      return data as T;\n    }\n\n    // Handle error responses\n    this.handleErrorResponse(response.status, data);\n  }\n\n  /**\n   * Handle error responses from the API\n   */\n  private handleErrorResponse(status: number, data: unknown): never {\n    const message = this.extractErrorMessage(data);\n\n    switch (status) {\n      case 401:\n        throw new AuthenticationError(message);\n      case 404:\n        throw new NotFoundError(message);\n      case 429: {\n        const retryAfter = this.extractRetryAfter(data);\n        throw new RateLimitError(message, retryAfter);\n      }\n      default:\n        throw new ApiError(message || `API error: ${status}`, status, data);\n    }\n  }\n\n  /**\n   * Extract error message from response data\n   */\n  private extractErrorMessage(data: unknown): string {\n    if (typeof data === 'string') {\n      return data;\n    }\n\n    if (data && typeof data === 'object') {\n      const obj = data as Record<string, unknown>;\n      if (typeof obj.Error === 'string') return obj.Error;\n      if (typeof obj.error === 'string') return obj.error;\n      if (typeof obj.message === 'string') return obj.message;\n    }\n\n    return 'An unknown error occurred';\n  }\n\n  /**\n   * Extract retry-after value from response\n   */\n  private extractRetryAfter(data: unknown): number | undefined {\n    if (data && typeof data === 'object') {\n      const obj = data as Record<string, unknown>;\n      if (typeof obj.retry_after === 'number') return obj.retry_after;\n      if (typeof obj.retryAfter === 'number') return obj.retryAfter;\n    }\n    return undefined;\n  }\n\n  /**\n   * Sleep for a given duration\n   */\n  private sleep(ms: number): Promise<void> {\n    return new Promise((resolve) => setTimeout(resolve, ms));\n  }\n}\n","import type { HttpClient } from '../utils/http.js';\nimport type { Breach, BreachesResponse, GetBreachesOptions } from '../types/breaches.js';\n\n/**\n * Get a list of all known data breaches\n *\n * @param http - HTTP client instance\n * @param options - Optional filters\n * @returns List of breaches\n *\n * @example\n * ```typescript\n * // Get all breaches\n * const breaches = await getBreaches(http);\n *\n * // Filter by domain\n * const adobeBreaches = await getBreaches(http, { domain: 'adobe.com' });\n *\n * // Get specific breach\n * const breach = await getBreaches(http, { breachId: 'adobe' });\n * ```\n */\nexport async function getBreaches(\n  http: HttpClient,\n  options: GetBreachesOptions = {}\n): Promise<Breach[]> {\n  const params: Record<string, string | undefined> = {};\n\n  if (options.domain) {\n    params.domain = options.domain;\n  }\n\n  if (options.breachId) {\n    params.breach_id = options.breachId;\n  }\n\n  const response = await http.request<BreachesResponse>('/v1/breaches', {\n    params,\n  });\n\n  return response.exposedBreaches ?? [];\n}\n","import { ValidationError } from '../errors/index.js';\n\n/**\n * Regular expression for validating email addresses\n * This is a simplified pattern that covers most common cases\n */\nconst EMAIL_REGEX = /^[^\\s@]+@[^\\s@]+\\.[^\\s@]+$/;\n\n/**\n * Validate an email address\n * @param email - The email address to validate\n * @throws {ValidationError} If the email is invalid\n */\nexport function validateEmail(email: unknown): asserts email is string {\n  if (typeof email !== 'string') {\n    throw new ValidationError('Email must be a string', 'email');\n  }\n\n  const trimmed = email.trim();\n\n  if (!trimmed) {\n    throw new ValidationError('Email is required', 'email');\n  }\n\n  if (!EMAIL_REGEX.test(trimmed)) {\n    throw new ValidationError('Invalid email format', 'email');\n  }\n\n  if (trimmed.length > 254) {\n    throw new ValidationError('Email is too long (max 254 characters)', 'email');\n  }\n}\n\n/**\n * Validate a domain string\n * @param domain - The domain to validate\n * @throws {ValidationError} If the domain is invalid\n */\nexport function validateDomain(domain: unknown): asserts domain is string {\n  if (typeof domain !== 'string') {\n    throw new ValidationError('Domain must be a string', 'domain');\n  }\n\n  const trimmed = domain.trim();\n\n  if (!trimmed) {\n    throw new ValidationError('Domain is required', 'domain');\n  }\n\n  // Basic domain validation\n  const domainRegex = /^[a-zA-Z0-9][a-zA-Z0-9-_.]+\\.[a-zA-Z]{2,}$/;\n  if (!domainRegex.test(trimmed)) {\n    throw new ValidationError('Invalid domain format', 'domain');\n  }\n}\n\n/**\n * Normalize an email address (trim and lowercase)\n * @param email - The email address to normalize\n * @returns The normalized email\n */\nexport function normalizeEmail(email: string): string {\n  return email.trim().toLowerCase();\n}\n\n/**\n * Sanitize an email address for use in URL paths\n * @param email - The email address to sanitize\n * @returns The URL-encoded email for path segments\n */\nexport function sanitizeEmailForPath(email: string): string {\n  return encodeURIComponent(normalizeEmail(email));\n}\n","import type { HttpClient } from '../utils/http.js';\nimport type {\n  CheckEmailResponse,\n  CheckEmailOptions,\n  CheckEmailResult,\n} from '../types/check-email.js';\nimport { validateEmail, sanitizeEmailForPath } from '../utils/validation.js';\nimport { NotFoundError } from '../errors/index.js';\n\n/**\n * Type guard to check if response indicates email was found\n */\nfunction isFoundResponse(\n  response: CheckEmailResponse\n): response is { breaches: string[][]; email: string } {\n  return 'breaches' in response && Array.isArray(response.breaches);\n}\n\n/**\n * Check if an email address has been exposed in any data breaches\n *\n * @param http - HTTP client instance\n * @param email - Email address to check\n * @param options - Optional parameters\n * @returns Result indicating if email was found and which breaches\n *\n * @example\n * ```typescript\n * const result = await checkEmail(http, 'test@example.com');\n *\n * if (result.found) {\n *   console.log(`Found in ${result.breaches.length} breaches`);\n *   console.log(result.breaches);\n * } else {\n *   console.log('Email not found in any breaches');\n * }\n * ```\n */\nexport async function checkEmail(\n  http: HttpClient,\n  email: string,\n  options: CheckEmailOptions = {}\n): Promise<CheckEmailResult> {\n  validateEmail(email);\n\n  const sanitizedEmail = sanitizeEmailForPath(email);\n  const params: Record<string, string | boolean | undefined> = {};\n\n  if (options.includeDetails) {\n    params.include_details = options.includeDetails;\n  }\n\n  try {\n    const response = await http.request<CheckEmailResponse>(`/v1/check-email/${sanitizedEmail}`, {\n      params,\n    });\n\n    if (isFoundResponse(response)) {\n      // Flatten the nested array of breaches\n      const breaches = response.breaches.flat();\n\n      return {\n        email: response.email,\n        found: true,\n        breaches,\n      };\n    }\n\n    // Response indicates not found\n    return {\n      email: response.email,\n      found: false,\n      breaches: [],\n    };\n  } catch (error) {\n    // 404 means email not found in any breaches (this is expected)\n    if (error instanceof NotFoundError) {\n      return {\n        email,\n        found: false,\n        breaches: [],\n      };\n    }\n\n    throw error;\n  }\n}\n","import type { HttpClient } from '../utils/http.js';\nimport type { BreachAnalyticsResponse, GetBreachAnalyticsOptions } from '../types/analytics.js';\nimport { validateEmail, normalizeEmail } from '../utils/validation.js';\nimport { NotFoundError } from '../errors/index.js';\n\n/**\n * Normalized breach analytics result\n */\nexport interface BreachAnalyticsResult {\n  /** The email address that was checked */\n  email: string;\n\n  /** Whether the email was found in any breaches */\n  found: boolean;\n\n  /** Raw analytics data from the API */\n  analytics: BreachAnalyticsResponse | null;\n}\n\n/**\n * Get detailed breach analytics for an email address\n *\n * @param http - HTTP client instance\n * @param email - Email address to get analytics for\n * @param options - Optional parameters\n * @returns Detailed analytics about breaches and paste exposures\n *\n * @example\n * ```typescript\n * const result = await getBreachAnalytics(http, 'test@example.com');\n *\n * if (result.found && result.analytics) {\n *   console.log('Breaches:', result.analytics.ExposedBreaches);\n *   console.log('Summary:', result.analytics.BreachesSummary);\n *   console.log('Metrics:', result.analytics.BreachMetrics);\n * }\n * ```\n */\nexport async function getBreachAnalytics(\n  http: HttpClient,\n  email: string,\n  options: GetBreachAnalyticsOptions = {}\n): Promise<BreachAnalyticsResult> {\n  validateEmail(email);\n\n  const normalizedEmail = normalizeEmail(email);\n  const params: Record<string, string | undefined> = {\n    email: normalizedEmail,\n  };\n\n  if (options.token) {\n    params.token = options.token;\n  }\n\n  try {\n    const response = await http.request<BreachAnalyticsResponse>('/v1/breach-analytics', {\n      params,\n    });\n\n    // Check if there's actual data\n    const breachDetails = response.ExposedBreaches?.breaches_details;\n    const hasBreaches = breachDetails !== undefined && breachDetails.length > 0;\n    const hasPastes = Array.isArray(response.ExposedPastes) && response.ExposedPastes.length > 0;\n\n    return {\n      email,\n      found: hasBreaches || hasPastes,\n      analytics: response,\n    };\n  } catch (error) {\n    if (error instanceof NotFoundError) {\n      return {\n        email,\n        found: false,\n        analytics: null,\n      };\n    }\n\n    throw error;\n  }\n}\n","import type {\n  XposedOrNotConfig,\n  ResolvedConfig,\n  Breach,\n  GetBreachesOptions,\n  CheckEmailOptions,\n  CheckEmailResult,\n  GetBreachAnalyticsOptions,\n} from './types/index.js';\nimport { DEFAULT_CONFIG } from './types/config.js';\nimport { HttpClient } from './utils/http.js';\nimport { ValidationError } from './errors/index.js';\nimport { getBreaches } from './endpoints/breaches.js';\nimport { checkEmail } from './endpoints/check-email.js';\nimport { getBreachAnalytics, type BreachAnalyticsResult } from './endpoints/breach-analytics.js';\n\n/**\n * XposedOrNot API client\n *\n * @example\n * ```typescript\n * import { XposedOrNot } from 'xposedornot';\n *\n * const xon = new XposedOrNot();\n *\n * // Check if an email has been breached\n * const result = await xon.checkEmail('test@example.com');\n * console.log(result.found ? 'Breached!' : 'Safe');\n *\n * // Get all known breaches\n * const breaches = await xon.getBreaches();\n *\n * // Get detailed analytics\n * const analytics = await xon.getBreachAnalytics('test@example.com');\n * ```\n */\nexport class XposedOrNot {\n  private readonly config: ResolvedConfig;\n  private readonly http: HttpClient;\n\n  /**\n   * Create a new XposedOrNot client\n   *\n   * @param config - Optional configuration options\n   */\n  constructor(config: XposedOrNotConfig = {}) {\n    this.config = this.resolveConfig(config);\n    this.http = new HttpClient(this.config);\n  }\n\n  /**\n   * Merge user config with defaults and validate\n   */\n  private resolveConfig(config: XposedOrNotConfig): ResolvedConfig {\n    // Validate and resolve baseUrl\n    const baseUrl = config.baseUrl ?? DEFAULT_CONFIG.baseUrl;\n    this.validateBaseUrl(baseUrl);\n\n    // Validate and resolve timeout\n    const timeout = config.timeout ?? DEFAULT_CONFIG.timeout;\n    this.validateTimeout(timeout);\n\n    // Validate and resolve retries\n    const retries = config.retries ?? DEFAULT_CONFIG.retries;\n    this.validateRetries(retries);\n\n    return {\n      baseUrl,\n      timeout,\n      retries,\n      headers: {\n        ...DEFAULT_CONFIG.headers,\n        ...config.headers,\n      },\n    };\n  }\n\n  /**\n   * Validate baseUrl - must be HTTPS\n   */\n  private validateBaseUrl(baseUrl: string): void {\n    // Check if it's a valid URL\n    let url: URL;\n    try {\n      url = new URL(baseUrl);\n    } catch {\n      throw new ValidationError(`Invalid baseUrl: \"${baseUrl}\" is not a valid URL`, 'baseUrl');\n    }\n\n    // Enforce HTTPS\n    if (url.protocol !== 'https:') {\n      throw new ValidationError(\n        `Invalid baseUrl: must use HTTPS protocol (got \"${url.protocol}\")`,\n        'baseUrl'\n      );\n    }\n  }\n\n  /**\n   * Validate timeout - must be between 1000ms and 5 minutes\n   */\n  private validateTimeout(timeout: number): void {\n    const MIN_TIMEOUT = 1000; // 1 second\n    const MAX_TIMEOUT = 300000; // 5 minutes\n\n    if (typeof timeout !== 'number' || !Number.isFinite(timeout)) {\n      throw new ValidationError('Invalid timeout: must be a finite number', 'timeout');\n    }\n\n    if (timeout < MIN_TIMEOUT || timeout > MAX_TIMEOUT) {\n      throw new ValidationError(\n        `Invalid timeout: must be between ${MIN_TIMEOUT}ms and ${MAX_TIMEOUT}ms (got ${timeout}ms)`,\n        'timeout'\n      );\n    }\n  }\n\n  /**\n   * Validate retries - must be between 0 and 10\n   */\n  private validateRetries(retries: number): void {\n    const MIN_RETRIES = 0;\n    const MAX_RETRIES = 10;\n\n    if (typeof retries !== 'number' || !Number.isInteger(retries)) {\n      throw new ValidationError('Invalid retries: must be an integer', 'retries');\n    }\n\n    if (retries < MIN_RETRIES || retries > MAX_RETRIES) {\n      throw new ValidationError(\n        `Invalid retries: must be between ${MIN_RETRIES} and ${MAX_RETRIES} (got ${retries})`,\n        'retries'\n      );\n    }\n  }\n\n  /**\n   * Check if an email address has been exposed in any data breaches\n   *\n   * @param email - Email address to check\n   * @param options - Optional parameters\n   * @returns Result indicating if email was found and which breaches\n   *\n   * @example\n   * ```typescript\n   * const result = await xon.checkEmail('user@example.com');\n   *\n   * if (result.found) {\n   *   console.log(`Found in ${result.breaches.length} breaches:`);\n   *   result.breaches.forEach(breach => console.log(`  - ${breach}`));\n   * } else {\n   *   console.log('Good news! Email not found in any known breaches.');\n   * }\n   * ```\n   */\n  async checkEmail(email: string, options?: CheckEmailOptions): Promise<CheckEmailResult> {\n    return checkEmail(this.http, email, options);\n  }\n\n  /**\n   * Get a list of all known data breaches\n   *\n   * @param options - Optional filters for domain or specific breach\n   * @returns Array of breach information\n   *\n   * @example\n   * ```typescript\n   * // Get all breaches\n   * const allBreaches = await xon.getBreaches();\n   * console.log(`Total breaches: ${allBreaches.length}`);\n   *\n   * // Filter by domain\n   * const adobeBreaches = await xon.getBreaches({ domain: 'adobe.com' });\n   *\n   * // Get specific breach by ID\n   * const linkedIn = await xon.getBreaches({ breachId: 'linkedin' });\n   * ```\n   */\n  async getBreaches(options?: GetBreachesOptions): Promise<Breach[]> {\n    return getBreaches(this.http, options);\n  }\n\n  /**\n   * Get detailed breach analytics for an email address\n   *\n   * Provides comprehensive information including:\n   * - List of breaches where the email was found\n   * - Breach summary and metrics\n   * - Paste exposures (if any)\n   *\n   * @param email - Email address to get analytics for\n   * @param options - Optional parameters including access token\n   * @returns Detailed analytics about breaches and exposures\n   *\n   * @example\n   * ```typescript\n   * const result = await xon.getBreachAnalytics('user@example.com');\n   *\n   * if (result.found && result.analytics) {\n   *   const { ExposedBreaches, BreachesSummary, BreachMetrics } = result.analytics;\n   *\n   *   console.log('Exposed in breaches:', ExposedBreaches);\n   *   console.log('Summary:', BreachesSummary);\n   *   console.log('Metrics:', BreachMetrics);\n   * }\n   * ```\n   */\n  async getBreachAnalytics(\n    email: string,\n    options?: GetBreachAnalyticsOptions\n  ): Promise<BreachAnalyticsResult> {\n    return getBreachAnalytics(this.http, email, options);\n  }\n}\n"]}