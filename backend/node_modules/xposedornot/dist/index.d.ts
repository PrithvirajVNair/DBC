/**
 * Configuration options for the XposedOrNot client
 */
interface XposedOrNotConfig {
    /**
     * Base URL for the API (must use HTTPS)
     * @default 'https://api.xposedornot.com'
     * @throws {ValidationError} If not a valid HTTPS URL
     */
    baseUrl?: string;
    /**
     * Request timeout in milliseconds (1000-300000)
     * @default 30000
     * @throws {ValidationError} If outside valid range
     */
    timeout?: number;
    /**
     * Number of retry attempts for failed requests (0-10)
     * @default 3
     * @throws {ValidationError} If outside valid range
     */
    retries?: number;
    /**
     * Custom headers to include in all requests
     */
    headers?: Record<string, string>;
}

/**
 * Information about a single data breach
 */
interface Breach {
    /** Unique identifier for the breach */
    breachID: string;
    /** Date when the breach occurred */
    breachedDate: string;
    /** Domain associated with the breach */
    domain: string;
    /** Industry category of the breached organization */
    industry: string;
    /** URL to the breach logo */
    logo: string;
    /** Risk level associated with password exposure */
    passwordRisk: string;
    /** Whether the breach is searchable */
    searchable: boolean;
    /** Whether the breach contains sensitive data */
    sensitive: boolean;
    /** Whether the breach has been verified */
    verified: boolean;
    /** Types of data exposed in the breach */
    exposedData: string[];
    /** Number of records exposed */
    exposedRecords: number;
    /** Description of what was exposed */
    exposureDescription: string;
    /** Reference URL for more information */
    referenceURL: string;
}
/**
 * Response from the /v1/breaches endpoint
 */
interface BreachesResponse {
    status: string;
    exposedBreaches: Breach[] | null;
}
/**
 * Options for filtering breaches
 */
interface GetBreachesOptions {
    /** Filter breaches by domain */
    domain?: string;
    /** Get a specific breach by ID */
    breachId?: string;
}

/**
 * Response when an email is found in breaches
 */
interface CheckEmailFoundResponse {
    /** List of breach names where the email was found */
    breaches: string[][];
    /** The email address that was checked */
    email: string;
}
/**
 * Response when an email is not found in any breaches
 */
interface CheckEmailNotFoundResponse {
    /** Error message indicating email was not found */
    Error: string;
    /** The email address that was checked */
    email: string;
}
/**
 * Combined response type for check-email endpoint
 */
type CheckEmailResponse = CheckEmailFoundResponse | CheckEmailNotFoundResponse;
/**
 * Options for checking an email
 */
interface CheckEmailOptions {
    /** Include detailed breach information */
    includeDetails?: boolean;
}
/**
 * Normalized result from checkEmail method
 */
interface CheckEmailResult {
    /** The email address that was checked */
    email: string;
    /** Whether the email was found in any breaches */
    found: boolean;
    /** List of breach names (empty if not found) */
    breaches: string[];
}

/**
 * Summary of breaches for an email
 */
interface BreachesSummary {
    /** Semicolon-separated list of breach sites */
    site?: string;
    /** Additional summary fields */
    [key: string]: unknown;
}
/**
 * Risk assessment for the email
 */
interface RiskAssessment {
    risk_label: string;
    risk_score: number;
}
/**
 * Password strength breakdown
 */
interface PasswordStrength {
    EasyToCrack: number;
    PlainText: number;
    StrongHash: number;
    Unknown: number;
}
/**
 * Metrics about breaches
 */
interface BreachMetrics {
    /** Industry breakdown */
    industry?: unknown[][];
    /** Password strength analysis */
    passwords_strength?: PasswordStrength[];
    /** Risk assessment */
    risk?: RiskAssessment[];
    /** Exposed data categories */
    xposed_data?: unknown[];
    /** Year-wise breakdown */
    yearwise_details?: Record<string, number>[];
    /** Additional details */
    get_details?: unknown[];
    [key: string]: unknown;
}
/**
 * Summary of paste exposures
 */
interface PastesSummary {
    /** Count of pastes */
    cnt?: number;
    /** Domain */
    domain?: string;
    /** Timestamp */
    tmpstmp?: string;
    [key: string]: unknown;
}
/**
 * Metrics about paste exposures
 */
type PasteMetrics = Record<string, unknown>;
/**
 * Individual exposed breach details
 */
interface BreachDetails {
    /** Breach name/identifier */
    breach: string;
    /** Description of the breach */
    details: string;
    /** Domain associated with the breach */
    domain: string;
    /** Industry category */
    industry: string;
    /** URL to breach logo */
    logo: string;
    /** Password risk level */
    password_risk: string;
    /** Reference URLs */
    references: string;
    /** Whether the breach is searchable */
    searchable: string;
    /** Whether the breach is verified */
    verified: string;
    /** Types of data exposed (semicolon-separated) */
    xposed_data: string;
    /** Date of the breach */
    xposed_date: string;
    /** Number of records exposed */
    xposed_records: number;
    /** Date added to database */
    added: string;
}
/**
 * Container for exposed breaches
 */
interface ExposedBreaches {
    breaches_details: BreachDetails[];
}
/**
 * Individual exposed paste details
 */
type ExposedPaste = Record<string, unknown>;
/**
 * Response from the /v1/breach-analytics endpoint
 */
interface BreachAnalyticsResponse {
    /** Exposed breaches container with details */
    ExposedBreaches: ExposedBreaches | null;
    /** Summary of all breaches */
    BreachesSummary: BreachesSummary | null;
    /** Metrics about breaches */
    BreachMetrics: BreachMetrics | null;
    /** Summary of paste exposures */
    PastesSummary: PastesSummary | null;
    /** List of exposed pastes */
    ExposedPastes: ExposedPaste[] | null;
    /** Metrics about paste exposures */
    PasteMetrics: PasteMetrics | null;
}
/**
 * Options for getting breach analytics
 */
interface GetBreachAnalyticsOptions {
    /** Token for accessing sensitive data */
    token?: string;
}

/**
 * Normalized breach analytics result
 */
interface BreachAnalyticsResult {
    /** The email address that was checked */
    email: string;
    /** Whether the email was found in any breaches */
    found: boolean;
    /** Raw analytics data from the API */
    analytics: BreachAnalyticsResponse | null;
}

/**
 * XposedOrNot API client
 *
 * @example
 * ```typescript
 * import { XposedOrNot } from 'xposedornot';
 *
 * const xon = new XposedOrNot();
 *
 * // Check if an email has been breached
 * const result = await xon.checkEmail('test@example.com');
 * console.log(result.found ? 'Breached!' : 'Safe');
 *
 * // Get all known breaches
 * const breaches = await xon.getBreaches();
 *
 * // Get detailed analytics
 * const analytics = await xon.getBreachAnalytics('test@example.com');
 * ```
 */
declare class XposedOrNot {
    private readonly config;
    private readonly http;
    /**
     * Create a new XposedOrNot client
     *
     * @param config - Optional configuration options
     */
    constructor(config?: XposedOrNotConfig);
    /**
     * Merge user config with defaults and validate
     */
    private resolveConfig;
    /**
     * Validate baseUrl - must be HTTPS
     */
    private validateBaseUrl;
    /**
     * Validate timeout - must be between 1000ms and 5 minutes
     */
    private validateTimeout;
    /**
     * Validate retries - must be between 0 and 10
     */
    private validateRetries;
    /**
     * Check if an email address has been exposed in any data breaches
     *
     * @param email - Email address to check
     * @param options - Optional parameters
     * @returns Result indicating if email was found and which breaches
     *
     * @example
     * ```typescript
     * const result = await xon.checkEmail('user@example.com');
     *
     * if (result.found) {
     *   console.log(`Found in ${result.breaches.length} breaches:`);
     *   result.breaches.forEach(breach => console.log(`  - ${breach}`));
     * } else {
     *   console.log('Good news! Email not found in any known breaches.');
     * }
     * ```
     */
    checkEmail(email: string, options?: CheckEmailOptions): Promise<CheckEmailResult>;
    /**
     * Get a list of all known data breaches
     *
     * @param options - Optional filters for domain or specific breach
     * @returns Array of breach information
     *
     * @example
     * ```typescript
     * // Get all breaches
     * const allBreaches = await xon.getBreaches();
     * console.log(`Total breaches: ${allBreaches.length}`);
     *
     * // Filter by domain
     * const adobeBreaches = await xon.getBreaches({ domain: 'adobe.com' });
     *
     * // Get specific breach by ID
     * const linkedIn = await xon.getBreaches({ breachId: 'linkedin' });
     * ```
     */
    getBreaches(options?: GetBreachesOptions): Promise<Breach[]>;
    /**
     * Get detailed breach analytics for an email address
     *
     * Provides comprehensive information including:
     * - List of breaches where the email was found
     * - Breach summary and metrics
     * - Paste exposures (if any)
     *
     * @param email - Email address to get analytics for
     * @param options - Optional parameters including access token
     * @returns Detailed analytics about breaches and exposures
     *
     * @example
     * ```typescript
     * const result = await xon.getBreachAnalytics('user@example.com');
     *
     * if (result.found && result.analytics) {
     *   const { ExposedBreaches, BreachesSummary, BreachMetrics } = result.analytics;
     *
     *   console.log('Exposed in breaches:', ExposedBreaches);
     *   console.log('Summary:', BreachesSummary);
     *   console.log('Metrics:', BreachMetrics);
     * }
     * ```
     */
    getBreachAnalytics(email: string, options?: GetBreachAnalyticsOptions): Promise<BreachAnalyticsResult>;
}

/**
 * Base error class for all XposedOrNot errors
 */
declare class XposedOrNotError extends Error {
    readonly code: string;
    readonly statusCode?: number | undefined;
    constructor(message: string, code: string, statusCode?: number | undefined);
}
/**
 * Error thrown when the API rate limit is exceeded
 */
declare class RateLimitError extends XposedOrNotError {
    readonly retryAfter?: number | undefined;
    constructor(message?: string, retryAfter?: number | undefined);
}
/**
 * Error thrown when a resource is not found (e.g., email not in any breaches)
 */
declare class NotFoundError extends XposedOrNotError {
    constructor(message?: string);
}
/**
 * Error thrown when authentication fails
 */
declare class AuthenticationError extends XposedOrNotError {
    constructor(message?: string);
}
/**
 * Error thrown when input validation fails
 */
declare class ValidationError extends XposedOrNotError {
    readonly field?: string | undefined;
    constructor(message: string, field?: string | undefined);
}
/**
 * Error thrown when a network error occurs
 */
declare class NetworkError extends XposedOrNotError {
    readonly cause?: Error | undefined;
    constructor(message?: string, cause?: Error | undefined);
}
/**
 * Error thrown when the request times out
 */
declare class TimeoutError extends XposedOrNotError {
    constructor(message?: string);
}
/**
 * Error thrown when the API returns an unexpected response
 */
declare class ApiError extends XposedOrNotError {
    readonly response?: unknown | undefined;
    constructor(message: string, statusCode: number, response?: unknown | undefined);
}

export { ApiError, AuthenticationError, type Breach, type BreachAnalyticsResponse, type BreachAnalyticsResult, type BreachDetails, type BreachMetrics, type BreachesResponse, type BreachesSummary, type CheckEmailFoundResponse, type CheckEmailNotFoundResponse, type CheckEmailOptions, type CheckEmailResponse, type CheckEmailResult, type ExposedBreaches, type ExposedPaste, type GetBreachAnalyticsOptions, type GetBreachesOptions, NetworkError, NotFoundError, type PasswordStrength, type PasteMetrics, type PastesSummary, RateLimitError, type RiskAssessment, TimeoutError, ValidationError, XposedOrNot, type XposedOrNotConfig, XposedOrNotError };
